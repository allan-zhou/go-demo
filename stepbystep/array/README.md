# array

- 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列（这是一种同构的数据结构）

> **数组长度**也是数组类型的一部分，所以[5]int和[10]int是属于不同类型的
>
> 数组的编译时值初始化是按照数组顺序完成的
>
> 如果我们想让数组元素类型为任意类型的话可以使用空接口作为类型
>
> 元素的数目，也称为长度或者数组大小必须是固定的并且在声明该数组时就给出（编译时需要知道数组长度以便分配内存）；数组长度最大为 2Gb

- Go 语言中的数组是一种 值类型,所以可以通过 **new()** 来创建

代码示例：[arry-copy.go](./array-copy/array-copy.go)

```go
var arr1 = new([5]int)
var arr2 [5]int

// arr1 的类型是 *[5]int，arr2的类型是 [5]int
// 这样的结果就是当把一个数组赋值给另一个时，需要在做一次数组内存的拷贝操作。例如：
// arr2 := *arr1
// arr2[2] = 100
```

- 数组常量声明

```go
arr1 := [5]int{1,2,3}

arr2 :=[...]int{1,2,3}

arr3 := [5]string{2:"two", 3:"three"}
```

- 数组作为函数参数传递

> 把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象：
>
> 1. 传递数组的指针
>
> 1. 传递数组的切片

## 切片

切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型。

- 切片是一个 长度可变的数组， 切片的长度可以在运行时修改

 切片的长度永远不会超过它的容量。

 不等式永远成立：0 <= len(s) <= cap(s)

多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。

``` go
// 声明切片,不需要说明长度
//一个切片在未初始化之前默认为 nil，长度为 0
var identifier []type

//切片的初始化格式是
var slice1 []type = arr1[start:end]

// 以下几种方式等价
var slice1 []type = arr1[:]
var slice1 []type = arr1[0:len(arr1)]
slice1 = &arr1
```

```go
// 一个由数字 1、2、3 组成的切片
slice := []int{1,2,3}[:]
slice := []int{1,2,3}
```

## 使用make创建切片

```go
// make 接受 3 个参数：元素的类型、切片长度、切片容量。其中cap是可选参数
// 当忽略cap时， len(s) == cap(s)
func make([]T, len, cap)
```

```go
var slice1 []type = make([]type, len)
//简写
slice1 := make([]type,len)
```

## new() 和 make() 的区别

- 两者都在堆上分配内存

- new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针。它适用于**值类型**，如数组和结构体

- make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的**引用类型**：切片、map 和 channel

[new() & make()](./images/new&make.png)
